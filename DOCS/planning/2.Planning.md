# Planning

The `PlanningEngine` is a forward-chaining system that translates recipe steps into executable plans. It iterates over each recipe step, resolves required equipment, classifies the step type, and dispatches a `step_request` fact to specialized rules via forward chaining. Orchestration rules receive the engine instance, enabling nested forward chaining and multi-level rule composition.

## System Overview

The engine processes each recipe step sequentially. For each step it:

1. **Resolves equipment**: determines what equipment is needed (ovens, bowls, baking sheets) and allocates from the available pool.
2. **Classifies the step type**: uses `_build_step_request` to identify the step as MIXING, COOK, TRANSFER_ITEM, TRANSFER_EQUIPMENT, EQUIPMENT_REMOVAL, or ITEM_TRANSFER_TO_SURFACE based on the step's `step_type` class attribute.
3. **Dispatches a `step_request` fact**: asserts the classified request into Working Memory, where specialized dispatch rule modules (one per step type) handle the planning logic via forward chaining.

Equipment follows a state machine lifecycle tracked entirely through Working Memory facts: **AVAILABLE -> RESERVED -> IN_USE -> DIRTY -> (cleaning rule) -> AVAILABLE**. SURFACE equipment (COOLING_RACK, COUNTERTOP) is treated as always-available with infinite capacity.

Orchestration rules receive the engine instance via `bindings['_engine']`, enabling nested forward chaining. For example, a mixing dispatch rule can trigger sub-chains for each ingredient addition within a single mixing step.

## 1. Your Code

All logic for planning is located in the `ROOT/planning` directory.

Rules and Facts are located in the `ROOT/planning/rules` and `ROOT/planning/facts` directories.

The `ROOT/planning/main.py` is the entrypoint and the `ROOT/planning/engine.py` contains all inference logic for the Rule Based Expert System.

### Classes

#### Shared Classes (between scaling and planning)

##### "Brain" Classes

- [KnowledgeBase](/classes/KnowledgeBase.py)
- [WorkingMemory](/classes/WorkingMemory.py)

##### Rule Based Expert System Classes

- [Fact](/classes/Fact.py)
- [Rule](/classes/Rule.py)
- [NegatedFact](/classes/NegatedFact.py)

##### Recipe / Cooking Domain Classes

- [Recipe](/classes/Recipe.py)
- [Ingredient](/classes/Ingredient.py)

##### [Explanation Facility](/classes/ExplanationFacility.py)

#### Planning Specific Classes

- [Step](/planning/classes/Step.py)
- [CleaningStep](/planning/classes/CleaningStep.py)
- [CookStep](/planning/classes/CookStep.py)
- [MixingStep](/planning/classes/MixingStep.py)
- [MixingSubstep](/planning/classes/MixingSubstep.py)
- [TransferStep](/planning/classes/TransferStep.py)
- [TransferItem](/planning/classes/TransferItem.py)
- [TransferEquipment](/planning/classes/TransferEquipment.py)
- [WaitStep](/planning/classes/WaitStep.py)
- [PreheatStep](/planning/classes/PreheatStep.py)

## Design Decisions

- **Sequential step processing (no batching)**: Each recipe step is processed in isolation, in order. Batching across limited equipment like scheduling multiple baking sheets across ovens was explored but proved too complex for a pure rule-based approach within the project's time constraints.

- **Step type dispatch pattern**: `_build_step_request` classifies each step by its `step_type` class attribute (MIXING, COOK, TRANSFER_ITEM, etc.) and asserts a `step_request` fact. Specialized dispatch rule modules (one per step type) handle the planning logic. This keeps dispatch rules focused and modular: adding a new step type means adding a new dispatch module without modifying existing ones.

- **Engine injection via bindings**: `bindings['_engine']` gives action functions access to the engine for nested forward chaining. This enables multi-level rule composition, where a high-level dispatch rule can trigger sub-chains like a mixing dispatch rule triggers sub-chains for each ingredient addition within a single mixing step.

- **Equipment state machine as facts**: Equipment lifecycle (AVAILABLE, RESERVED, IN_USE, DIRTY) is tracked entirely via Working Memory facts rather than external mutable state. Rules can pattern-match on equipment status, enabling declarative equipment allocation and cleanup.

- **Priority-only conflict resolution**: Planning dispatch rules require strict sequencing like initialize mixing at priority 200, then process ingredients at 190, then finalize at 100. Specificity-based resolution cannot guarantee this ordering because rules at different stages may have the same number of antecedents. Priority values provide explicit, predictable control over firing order.

- **NegatedFact iteration pattern**: Rules like "process next pending ingredient" use NegatedFact guards like `NOT ingredient_added` combined with WM-size-aware fired keys. Each time a new fact is added to Working Memory, the fired key changes, re-enabling the rule to fire for the next pending item. This allows a single rule definition to iterate over an arbitrary number of items.

## How to Run

> [!WARNING]
> 
> You **must** include the `--run_planning_engine` flag to trigger the planning logic.

Call the `main.py` script in the ROOT of the directory with the following flags:

| Flag                    | Type    | Default   | Description                                       |
|-------------------------|---------|-----------|---------------------------------------------------|
| --run_planning_engine   | _n/a_   | False     | run the planning logic                            | 
| --scaling_factor        | float   | 2         | change scaling factor                             |             
| --num_ovens             | int     | 4         | change number of available ovens                  |
| --num_bowls             | int     | 1         | change number of available bowls                  |
| --num_baking_sheets     | int     | 5         | change number of available baking sheets          |
| --explain               | n/a     | False     | run the explanation REPL at the end of the script |

### Using UV

```
uv run python main.py --run_planning_engine --scaling_factor 200 --num_ovens 2 --num_bowls 4 --num_baking_sheets 4 --explain
```

### Pure Python

```
python main.py --run_planning_engine --scaling_factor 200 --num_ovens 2 --num_bowls 4 --num_baking_sheets 4  --explain
```
