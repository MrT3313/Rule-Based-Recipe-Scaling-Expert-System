================================================================================
BACKWARD CHAINING SAMPLE OUTPUT
================================================================================

This file demonstrates the expected output format for Backward Chaining.
Students should follow this trace format when implementing fol_bc_ask().

================================================================================
DUMMY KNOWLEDGE BASE
================================================================================

% --- Facts ---
Male(Adam)
Male(Bob)
Female(Carol)
Parent(Adam, Bob)
Parent(Bob, Carol)
Parent(Carol, Diana)

% --- Rules ---
Parent(p, c) && Male(p) => Father(p, c)
Parent(p, c) && Female(p) => Mother(p, c)
Parent(x, y) => Ancestor(x, y)
Parent(x, z) && Ancestor(z, y) => Ancestor(x, y)

================================================================================
EXPECTED OUTPUT FROM run_logic.py
================================================================================

Successfully loaded Knowledge Base from dummy.kb.
  6 facts, 4 rules.

Running Backward Chaining for query: Ancestor(Adam, Diana)

Query: Ancestor(Adam, Diana)
  Trying fact: Parent(Adam, Bob) -> no match
  Trying rule: Parent(x, y) => Ancestor(x, y)
    Subgoal: Parent(Adam, Diana)
      ...Failed.
  Trying rule: Parent(x, z) && Ancestor(z, y) => Ancestor(x, y)
    Subgoal: Parent(Adam, z_1)
      Matched: Parent(Adam, Bob) with {z_1: Bob}
    Subgoal: Ancestor(Bob, Diana)
      Matched: Parent(Bob, z_2) with {z_2: Carol}
      New Query: Ancestor(Carol, Diana)
        Subgoal: Parent(Carol, Diana)
          Matched: Parent(Carol, Diana)
        ...Success.
  Proof found: {z_1: Bob, z_2: Carol}

  --- Proof 1 Found ---
  Result: {z_1: Bob, z_2: Carol}

================================================================================
IMPORTANT: WHAT YOUR fol_bc_ask() SHOULD PRINT VS run_logic.py
================================================================================

Your fol_bc_ask() function should print the search trace INCLUDING:
- "Query: Ancestor(Adam, Diana)"
- The search process (trying facts/rules, subgoals, matches)
- "Proof found: {z_1: Bob, z_2: Carol}" (right before yielding)

Then your function YIELDS the substitution dictionary: {z_1: Bob, z_2: Carol}

The run_logic.py script prints BEFORE and AFTER your function:
- BEFORE: "Successfully loaded Knowledge Base..." and "Running Backward Chaining..."
- AFTER (when it receives your yield): "--- Proof 1 Found ---" and "Result: ..."

So the complete output combines your trace with run_logic.py's wrapper messages.

================================================================================
EXPLANATION OF THE TRACE
================================================================================

The trace follows the format specified in the assignment:
- Indentation shows goal depth (2 spaces per level)
- Shows which facts/rules are being tried
- Shows subgoals for rules with antecedents
- Shows substitutions when unification succeeds
- Shows "...Failed" when a branch doesn't succeed
- Shows "...Success" when a proof is found
- Reports the final substitution when a proof is complete

Key points:
1. Variable standardization ensures unique variable names (z_1, z_2, etc.)
2. Subgoals are indented to show the proof tree structure
3. Each matched fact/rule shows the substitution applied
4. The algorithm backtracks when a subgoal fails

================================================================================
